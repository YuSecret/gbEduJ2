Верно ли мое понимание логики работы - при нажатии старта мы отдаем стороне сервера отмашку пинговать ловлю сокетов и если он ловит мы создаем новый сокет в onSocketAccepted(server, socket) - new SocketThread..
Клиент же при коннекте также создает новый сокет new SocketThread и готов принимать или отправлять данные, при отправке сообщения мы даем SocketThread прочитать данные и при этом поток SocketThread созданый при коннекте всегда пингует получение данные и поэтому мы сразу читаем полученное сообщение и с помощью onReseiveString выводим его в Log
Вопрос - где они находят друг друга? Где инь-янь соединяются?

1) ClientGUI.java
107 строка - connect()
Если по какой-то причине 110 строка не сработает, то новый SocketThread создастся с третьим аргументом в виде null и уже внутри SocketThread можно встретить на 24 строке (и не только), будет ловиться IOException при socket.getInputStream()? Если да, то можно ли это перехватить раньше, не создавая новый поток?

2) SocketThread.java
42 строка - sendMessage(String msg)
Метод возвращает boolean, однако это не используется в дальнейшем. Для чего так сделано?

3) Интерфейсы созданы для того, чтобы если бы мы захотели написать новый/переписать GUI сервера или клиента - нам бы не пришлось переписывать network часть?

1. В примере для ServerSocketThread рассматривался таймаут (для перепроверки accepted у сервера), является ли это типовым решением
и как должно в реальности на продуктиве,

2. При создании сокета используется ввод и вывод (не пишу слово поток), stream имеет какую то связь с Thread в Java?
Input и OutputStream работают в одном потоке или разных

Коммент1) После просмотра вебинара Java от Степченко - код стал более менее понятен, только у нас код немного закручен вокруг слушателей, с которыми разбираюсь далее
Коммент2) Посмотрел вебинар на тему многопоточности и создания чата (ITVDN) - основы более чем ясны, главное был понятен принцип сокетов. Есть всего лишь in и out. А дальше как нужно, так и обрабатываем
Вопрос 1) Несовсем понятно, какое значение принимает super(name) в конструкторе ServerSocketThread, если сервер всего-лишь один?
Вопрос 2) Зачем нужно было создавать два интерфейса, если можно было сделать по принципу "телефона" (из вебинара ITVDN) - там все в одном классе сделали. Вот тут немного непонятно, по сравнению с нашим чатом

Вопрос только один
@Override
public void onSocketAccepted(ServerSocket server, Socket socket) {
putLog("Socket accept");
String name = "SocketThread " + socket.getInetAddress() + ":" + socket.getPort();
new SocketThread(this, name, socket);
}
что мы здесь сделали, как то не зашло

для подключений мы будем использовать создание потоков через анонимный класс, а когда мы вообще создаем отдельный класс для потоков ? Сколько примеров посмотрел, повсюда через раннебл делают потоки.

1. Метод connect класса ClientGUI

    private void connect() {
        Socket socket = null;
        try {
            socket = new Socket(tfIPAddress.getText(), Integer.parseInt(tfPort.getText()));
        } catch (IOException e) {
            showException(e);
        }
        socketThread = new SocketThread(this, "Client", socket);
    }

каждый раз при нажатии кнопки логин создается новый сокет.
Наверное этого недолжно быть?.. как то блокировать логин

2. Попытался реализовать disconnect в классе ClientGUI
Добавил в листенер
        else if (src == btnDisconnect) {
            disconnect();
        }

в методе написал

    private void disconnect() {
        socketThread.close();
    }

вроде бы в методе close
    public synchronized void close() {
        interrupt();
        try {
            socket.close();
        } catch (IOException e) {
            listener.onSocketThreadException(this, e);
        }
    }

поток прерывается, сокет закрывается, должно работать. Но не работает(
Так и не понял почему ловлю эксепшн на  строке String msg = in.readUTF();
ведь поток прерван, и проверка есть while (!isInterrupted())

java.net.SocketException: Socket closed
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
	at java.net.SocketInputStream.read(SocketInputStream.java:171)
	at java.net.SocketInputStream.read(SocketInputStream.java:141)
	at java.net.SocketInputStream.read(SocketInputStream.java:224)
	at java.io.DataInputStream.readUnsignedShort(DataInputStream.java:337)
	at java.io.DataInputStream.readUTF(DataInputStream.java:589)
	at java.io.DataInputStream.readUTF(DataInputStream.java:564)
	at ru.gb.network.SocketThread.run(SocketThread.java:28)


Пересмотрел на два раза вебинар и более-менее разобрался с особенностью взаимодействия модулей кода из урока. Но, всё-равно, довольно сложно удержать всю эту систему в голове. Есть несколько вопросов:
1. В случае остановки потоков, что будет происходить с порождёнными сокетами? Они сами умрут столкнувшись с эксепшенами?
2. В уроке вы разделили наш проект на модули, а классы ServerSocketThread и SocketThread(+сопутствующие интерфейсы) получились универсальными - их легко переносить из проекта в проект, применяя в дальнейшем. Вопрос - данный подход в построении архитектуры является предпочтительным? В чём плох другой подход (в чём преимущества и недостатки) - когда классы много знают друг о друге? У меня есть предположение, что последний вариант плох тем, что такие классы трудно потдаются рефакторингу и становятся менее универсальными, гибкими. Что скажете вы? Можете уделить этому моменту немного времени?

   private void connect() {
        Socket socket = null;
        try {
            socket = new Socket(tfIPAddress.getText(), Integer.parseInt(tfPort.getText()));
        } catch (IOException e) {
            showException(e);
        }
        socketThread = new SocketThread(this, "Client", socket);
    }

Вопрос возник только по коду и только один.
Если при создании socket возникнет exception, то смысл создавать SocketThread.
И почему компилятор не предупредил, что socket может быть не инициализирован.

1. "У сервера 65536 портов". Это конкретная цифра? Почему именно столько?

2.Подход, описанный в методичке плох только с точки зрения гибкой архитектуры? Есть ещё какие-то минусы?

3. Возможно ли отправлять с помощью этого чата не только текст, но и, например, картинки, файлыб музыку?  Это делается через эти же потоки ввода/вывода?

1. кто и как определяет из каких модулей состоит проект?
Логика разделения на клиент-сервер-нетворк-коммон. Это вопрос разработчика или РП или кого-то другого?
Ведь, возомжно, в огромном проекте, универсальным блоком нужно сделать что-то не то,
что приходит в голову разработчику, особенно если он не в курсе всего проекта.

2. В уроке было использовано слово "Манифест", не очень поняла, что это.

3. Если взять наш нетворк, написать какой-нибудь класс игра с имплементами нетворковскими,
то нам останется только переопределить методы нетворковских интерфейсов так, как нам надо
в нашей новой игре и всё заработает? так ведь?

4. Не совсем понятно, зачем мы столько параметров передаем в методы, они не все задействованы.
Или это из-за того, что мы хотим универсальности нетворка и ожиидаем,
что следующий проект задействует всё?

5. с взаимодействием модулей и классов вроде разобралась, а вот с потоками чуть сложнее. Мы то тут,
то там создаем новый поток. Не могли бы вы нарисовать на схеме взаимодействия модулей и классов проекта,
где у нас запускаются новые потоки и что в каждом из этих потоков в итоге будет идти.














