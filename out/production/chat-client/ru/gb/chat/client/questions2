И опять, верно ли мое понимание логики:
При нажатии старта в serverGui создается полусокет (подключается к порту) и сразу происходит onServerStart в ChatServer где мы коннектимся к нашей базе данных, чтобы она была готова работать с базой данных, и сразу инизиализируется метод onSocketAccepted где мы создаем наш клиентоориентированный поток ClientThread (по сути тот же SocketThread) где открывается новый поток откуда мы отлавливаем onSocketReady и onReseiveString
в ClientGUI при коннекте тоже создается поток SocketThread где создается полусокет (подключается к тому же порту) и сразу же в onSocketReady мы отправляем завуалированное сообщение что мы - такой логин и пароль - зарегестрируй нас ChatServer получается связующим звеном пары потоков ввода-вывода с обеих сторон и в onReseiveString мы проверяем все поступающие сообщения ( могут быть завуалированные о действиях юзеров или обычные сообщения)
объясните, пожалуйста, принцип работы джарника sqlite- это что-то вроде import? Или как модуль в модуле?

2) Вопрос: в процессе разбора пропало понимание класса Библиотеки...вот прям совсем. Мы же можем изначально передавать в другом виде информацию о "логине и пароле"...как-то намного проще
4) Вопрос: у нас есть такая штука в библиотеке, как время текущее. И сколько бы я не пытался обернуть его в DateFormat или симпл - выходит ошибка - что не корректный перевод (гугл забит информацией, не смог уловить основную мысль
1) Немного не по теме: можно ли запустить через IDEA несколько клиентов для проверки?
2) SqlClient.java
private final Vector<SocketThread> clients = new Vector<>();
Мы используем вектор, потому что он синхронизирован? (почему именно вектор?)
3) Library.java
public static String getAuthDenied() - зачем нужен метод, если поле public?

Вопрос такой появился, почему бы не использовать просто коллекцию для пользователей, которая будет отображать участников в онлайне ? Ну типо бд для авторизации, а какой нибудь линкед лист для отображения он лайн, что бы можно было ремувать при разлогине.

Понимаю, что рассматриваем SQL вскользь, но через данный инструментарий работа с базой выглядит немного веселее на мой взгляд
preparedStatement = connection.prepareStatement("select nickname from users where login=? and password=?");
preparedStatement.setString(1, login);
preparedStatement.setString(2, password);
ResultSet set = preparedStatement.executeQuery();
return set.getString("nickname");

1.Почему для нашего чата выбран SQLLite ? Из-за простоты использования или по каким-то еще критериям? Как вообще выбирается как и где будут храниться данные какого-либо проекта?
Правильно ли я понимаю, что чтобы работать с MySQL или Postgrees (без разницы с чем), нужно просто скачать другой джарник и тоже подключить JDBC, а она уже умеет работать с любыми базами данных, как SQL, так и NoSQL?

2. Вот здесь:   connection = DriverManager.getConnection("jdbc:sqlite:chat.db");
В скобках прямой путь к нашей БД. Это путь где? Т.е. физически БД лежит в нашем проекте. Почему мы указываем этот путь, а не просто "chat.db"? Если это был бы chat.txt, то мы бы просто так написали и всё. Почему доступ к БД, которая лежит там же, где и файл .txt, только через эту конструкцию?
Если хранить  бд не в проекте, то как будет прописываться путь? С:\folder\jdbc:sqlite:chat.db ?

3. Вот здесь:

 try (ResultSet set = statement.executeQuery(query)) {
            if (set.next())
                return set.getString(1);


В set.getString(1) не проще обращаться не по номеру колонки, а по названию? Было бы более наглядно и не надо париться с 0 или с 1 идет индексация.

4.В ChatServer:
Зачем нам метод  handleAuthorizedMsg() ?
В блоке else метода handleNonAuthorizedMsg() делается же тоже самое? Или нет?

1. Для чего нужна библиотека Library и такие странные строки? Для чего через нее форматировать сообщения?
Это соглашение негласное такое?
2. Вопорос по прошлоу уроку. Извините, не нашла ответа) Где фактически соединяются полусокеты? Правильно ли я понимаю что IN одного  полусокета, это OUT другого полусокета и наоборот?

И подробнее рассказать что конкретно происходит в блоке кода Class.forName("org.sqlite.JDBC"); connection = DriverManager.getConnection("jdbc:sqlite:chat.db"); statement = connection.createStatement();